<!DOCTYPE html>
<html>
  <head>
    <script type = "text/javascript">

      let gl;
      let IsPause;
      let startTime, zoom, x0, y0;
      let frag_col, back_col, iterations;

      /* Fragment shader source */
      const shaderFs = `#version 300 es
        precision highp float;
        layout (location = 0) out vec4 o_color;

        uniform float u_time;
        uniform float u_view_x;
        uniform float u_view_y;
        uniform float u_zoom;

        uniform float u_Width;
        uniform float u_Height;

        uniform vec3 u_frag_col;
        uniform vec3 u_back_col;

        uniform int u_iterations;

        float Mandelbrot( vec2 Z )
        {
            int n = 0;

            vec2 Z0 = Z;

            while (length(Z) < 4.0 && n < u_iterations)
            {
              Z = vec2(Z.x * Z.x - Z.y * Z.y, Z.x * Z.y + Z.x * Z.y) + Z0;
              n++;
            }
            return float(n);
        }
        
        float Julia( vec2 Z, vec2 C )
        {
          int n = 0;

          while (length(Z) < 4.0 && n < u_iterations)
          {
            Z = C + vec2(Z.x * Z.x - Z.y * Z.y, 2.0 * Z.x * Z.y);
            n++;
          }
          return float(n);
        }

        float NutonT( vec2 Z, vec2 C )
        {
          int n = 0;
          
          while (length(Z) < 4.0 && n < u_iterations)
          {
            vec2 Z1 = vec2(Z.x * Z.x - Z.y * Z.y, Z.x * Z.y + Z.x * Z.y);
            vec2 Z2 = vec2(Z.x * Z1.x - Z.y * Z1.y - 1.0 / 3.0, Z.x * Z1.y + Z1.x * Z.y);
            vec2 Z1C = vec2(Z.x * C.x - Z.y * C.y, Z.x * C.y + C.x * Z.y);
            vec2 DZ1C = vec2(Z1C.x / (length(Z1C) * length(Z1C)), -Z1C.y / (length(Z1C) * length(Z1C)));
            Z = vec2(Z.x - (Z2.x * DZ1C.x - Z2.y * DZ1C.y), Z.y - (Z2.x * DZ1C.y + DZ1C.x * Z2.y));
            n++;
          }
          return float(n);
        }

        void main()
        {
          float x = gl_FragCoord.x, y = gl_FragCoord.y;
          float stime = 102.0 * sin(2.0 * 3.0 * u_time / 1000.0);

          float nX = 2.0 * (u_view_x + u_Width / (2.0 * u_zoom) * (2.0 * x / u_Width - 1.0)) / u_Width - 1.0;
          float nY = 2.0 * (u_view_y + u_Height / (2.0 * u_zoom) * (2.0 * y / u_Height - 1.0)) / u_Height - 1.0;

          vec2 Z = vec2(nX, nY);   
          vec2 C = vec2(0.35 + 0.047 * sin(stime * 0.001), 0.40 + 0.03 * sin(stime * 0.001));

          float n = Julia(Z, C) / float(u_iterations) * 4.0;
          /*
          n = Mandelbrot(Z) / float(u_iterations) * 4.0;
          
          C = vec2(0.30 + 0.1 * abs(sin(stime / 3.0) + 1.0), 0.47 + 0.1 * sin(stime / 3.0) + 0.1);
          n = NutonT(Z, C);     
          */ 

          o_color = vec4(u_back_col + (u_frag_col - u_back_col) * n, 1.0);
        }`;

      /* Vertex shader source */
      const shaderVs = `#version 300 es
        precision highp float;

        layout (location = 0) in vec2 a_pos;

        void main() 
        {
          gl_Position = vec4(a_pos, 0, 1);
        }`;

      function getShader(shaderStr, type) 
      {
        const shader = gl.createShader(type);

        gl.shaderSource(shader, shaderStr);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) 
        {
          alert(gl.getShaderInfoLog(shader));
        }

        return shader;
      }

      function initGL(canvas) 
      {
        gl = canvas.getContext("webgl2");
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
      }

      let u_time_location, u_view_x_location, u_view_y_location;
      let u_zoom_location;
      let u_Width_location, u_Height_location, u_mX_location, u_mY_location;
      let  u_frag_col_location, u_back_col_location, u_iterations_location;

      function initShaders() 
      {
        const vs = getShader(shaderFs, gl.FRAGMENT_SHADER);
        const fs = getShader(shaderVs, gl.VERTEX_SHADER);

        const program = gl.createProgram();
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          alert("Program linkage error");
        }

        gl.useProgram(program);

        u_time_location = gl.getUniformLocation(program, "u_time");
        u_zoom_location = gl.getUniformLocation(program, "u_zoom");
        
        u_Width_location = gl.getUniformLocation(program, "u_Width");
        u_Height_location = gl.getUniformLocation(program, "u_Height");
        u_view_x_location = gl.getUniformLocation(program, "u_view_x");
        u_view_y_location = gl.getUniformLocation(program, "u_view_y");
        
        u_frag_col_location = gl.getUniformLocation(program, "u_frag_col");
        u_back_col_location = gl.getUniformLocation(program, "u_back_col");
        u_iterations_location = gl.getUniformLocation(program, "u_iterations");
      }

      /* Vertex buffer object */
      let vertexBuffer;

      function initBuffer() 
      {
        vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        vertices = [-1, -1, 3, -1, -1, 3];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      }

      let MousePres = false; 
      let saveX = -18, saveY = -18;

      function onStart() 
      {
        let canvas = document.getElementById("webgl-canvas");

        canvas.onmousedown = (ev) => { MousePres = true; }
        canvas.onmouseup = (ev) => { MousePres = false; }
        canvas.onmousemove = (ev) =>
        {
          if (saveX == -18 || saveY == -18)
          {
            saveX = ev.x;
            saveY = ev.y;
          }
          if (MousePres)
          {
            x0 -= (ev.x - saveX) / zoom;
            y0 += (ev.y - saveY) / zoom;
          }
          saveX = ev.x;
          saveY = ev.y;
        }
        canvas.onwheel = (ev) => 
        { 
          zoom *= 1 - ev.deltaY / 1800; 
          x0 -= (saveX / zoom - gl.viewportWidth / (2 * zoom)) * ev.deltaY / 1800;
          y0 += (saveY / zoom - gl.viewportHeight / (2 * zoom)) * ev.deltaY / 1800;
        }
        
        initGL(canvas);
        initShaders();
        initBuffer();

        startTime = (new Date()).getMilliseconds();
        x0 = gl.viewportWidth / 2;
        y0 = gl.viewportHeight / 2;
        zoom = 1.0;
        IsPause = false;
        frag_col = document.getElementById("picker1").value;
        back_col = document.getElementById("picker2").value;
        iterations = document.getElementById("slider").value;
        document.getElementById("picker1").onchange = function()
        {
          frag_col = this.value; 
        };
        document.getElementById("picker2").onchange = function()
        {
          back_col = this.value;
        };
        document.getElementById("slider").onchange = function()
        {
          iterations = this.value;
        }
        drawScene();
      }

      function hexStringToVec3(str)
      {
        let n1 = parseInt(str.substring(1, 3), 16) / 255;
        let n2 = parseInt(str.substring(3, 5), 16) / 255;
        let n3 = parseInt(str.substring(5, 7), 16) / 255;
        return [n1, n2, n3]
      }

      function drawScene() 
      {
        gl.clearColor(0, 1, 0, 1);
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

        timeFromStart = (new Date()).getMilliseconds() - startTime;
        if (!IsPause)
        {
          gl.uniform1f(u_time_location, timeFromStart);
        }
        gl.uniform1f(u_view_x_location, x0);
        gl.uniform1f(u_view_y_location, y0);
        gl.uniform1f(u_zoom_location, zoom);
        gl.uniform1f(u_Width_location, gl.viewportWidth);
        gl.uniform1f(u_Height_location, gl.viewportHeight);
        gl.uniform1f(u_mX_location, saveX);
        gl.uniform1f(u_mY_location, saveY);
        gl.uniform3fv(u_frag_col_location, hexStringToVec3(frag_col));
        gl.uniform3fv(u_back_col_location, hexStringToVec3(back_col));
        gl.uniform1i(u_iterations_location, iterations);

        gl.drawArrays(gl.TRIANGLES, 0, 3);
        window.requestAnimationFrame(drawScene);
      } 
      </script>
  </head>
  <body onload = "onStart();">
    <div style = "display: flex;">
      <div>
        <canvas
        id = "webgl-canvas"
        style = "border: none"
        width = 1000
        height = 900
        ></canvas>
      </div>
      <div style = "flex: 50%;">
        <p style="font-size:80px;">
          <b><i><ins>CGSG FOREVER!</ins></i></b>
        </p>
        <span>
        <br><br>
        <p1 style = "font-size:30px; margin-right: 8px;"><strong>Iterations</strong></p1>
        <p1><strong><i>1</p1>
        <input
          id = "slider"
          type = "range"
          min = 1
          max = 1020
          value = 255
          step = 1
          style = "width: 300px;"/>
        <p1>1020</i></strong></p1>
        </span>
        <br><br><br>
        <p1 style = "font-size:30px;"><strong>Fractal main color</strong></p1>
        <input id = "picker1" type = "color" value = "#8d47d8" style = "width:102px; height:30px;"/>
        <br><br><br>
        <p1 style = "font-size:30px;"><strong>Background color</strong></p1>
        <input id = "picker2" type = "color" value = "#080308" style = "width:102px; height:30px;"/>  
        <br><br><br>
        <button style = "width: 118px; height:60px; font-size:30px;" onclick="IsPause = !IsPause;"><strong>Pause</strong></button>      
      </div>
    </div>
  </body>
</html>